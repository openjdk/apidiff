/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package jdk.codetools.apidiff;

import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.lang.model.SourceVersion;

import jdk.codetools.apidiff.model.AccessKind;

/**
 * The command-line options for the {@code apidiff} program.
 */
public class Options {

    static class BadOption extends Exception {
        private static final long serialVersionUID = -1L;
        final String key;
        final Object[] args;
        BadOption(String key, Object... args) {
            super(key + Arrays.toString(args));
            this.key = key;
            this.args = args;
        }
    }

    private final Log log;

    /**
     * A container for the options to configure an API.
     */
    public static class APIOptions {
        /**
         * The name of the API.
         */
        public final String name;

        /**
         * A short plain-text label for the API.
         */
        public String label;

        /**
         * The options to configure a file manager for the API.
         */
        public Map<String, List<String>> fileManagerOpts = new LinkedHashMap<>();

        /**
         * The value of the {@code --release} option for the API.
         */
        public String release;

        /**
         * The value of the {@code --source} option for the API.
         */
        public String source;

        /**
         * Whether or not {@code --enable-preview} has been specified.
         */
        public boolean enablePreview;

        /**
         * The API directory containing the documentation generated by javadoc.
         */
        public Path apiDir;

        /**
         * The location of a JDK build, from which to derive a series of options.
         */
        public Path jdkBuildDir;

        public APIOptions(String name) {
            this.name = name;
        }

        void addFileManagerOpt(String opt, String arg) {
            fileManagerOpts.computeIfAbsent(opt, _o -> new ArrayList<>()).add(arg);
        }

        public void showVerboseSummary(Log log) {
            log.err.println("Summary of options for API " + name);
            if (label != null && !label.equals(name)) {
                log.err.println("  label: " + label);
            }
            if (jdkBuildDir != null) {
                log.err.println("  [--jdk-build " + jdkBuildDir + "]");
            }
            if (!fileManagerOpts.isEmpty()) {
                fileManagerOpts.forEach((opt, list) -> {
                    log.err.println("  " + opt + " " + String.join(" ", list));
                });
            }
            if (release != null) {
                log.err.println("  --release " + release);
            }
            if (source != null) {
                log.err.println("  --source " + source);
            }
            if (enablePreview) {
                log.err.println("  --enable-preview");
            }
            if (apiDir != null) {
                log.err.println("  --api-directory " + apiDir);
            }
        }

        public String toString() {
            return "APIOptions[name:" + name
                    + ",label:" + label
                    + ",fmOpts:" + fileManagerOpts
                    + ",release:" + release
                    + ",source:" + source
                    + ",enablePreview:" + enablePreview
                    + ",apiDir:" + apiDir
                    + ",jdkBuildDir:" + jdkBuildDir
                    + "]";
        }
    }

    // env options
    Map<String, APIOptions> allAPIOptions = new LinkedHashMap<>();
    APIOptions currAPIOptions = null;
    boolean apiOption = false;

    // selection/filtering options
    List<String> includes = new ArrayList<>();
    List<String> excludes = new ArrayList<>();
    AccessKind access;
    Boolean compareDocComments;
    Boolean compareApiDescriptions;
    Boolean compareApiDescriptionsAsText;
    String jdkDocs;

    // output options
    Path outDir;
    String title;
    String description;
    Path notes;
    Path mainStylesheet;
    List<Path> extraStylesheets;
    List<Path> resourceFiles;
    boolean showEqual;

    /**
     * The position of additional text to be included in the report.
     */
    public enum InfoTextKind {
        /**
         * At the top of each page, above the header bar.
         * Intended for warning and status messages.
         */
        TOP,

        /**
         * Within the main header bar, on the right hand side.
         * Intended for a short name for the report.
         */
        HEADER,

        /**
         * Within the main footer bar, on the right hand side.
         * Intended for a short name for the report.
         */
        FOOTER,

        /**
         * At the bottom of each page, below the footer bar.
         * Intended for legal details, such as license and copyright info.
         */
        BOTTOM
    }

    private Map<InfoTextKind, String> infoText = new EnumMap<>(InfoTextKind.class);

    /**
     * The level for which messages should be generated in "verbose: mode.
     */
    public enum VerboseKind {
        /** Generate messages about comparing modules. */
        MODULE,
        /** Generate messages about comparing modules and packages. */
        PACKAGE,
        /** Generate messages about comparing modules, packages, and types. */
        TYPE,
        /** Generate messages about different items. */
        DIFFERENCES,
        /** Generate messages about missing items. */
        MISSING,
        /** Generate messages about the time taken. */
        TIME,
        /** Generate messages about handling the command-line options. */
        OPTIONS
    }

    private Set<VerboseKind> verboseKinds = EnumSet.noneOf(VerboseKind.class);

    // meta options
    boolean help;
    boolean version;

    // hidden options
    private Map<String, String> hidden = new HashMap<>();

    /**
     * The comparison mode, inferred from the `--include` options.
     * The mode determines the file manager locations in which to
     * look for the elements to be compared.
     */
    public enum Mode {
        /**
         * Elements are in modules, to be found on the aggregate module path.
         */
        MODULE,
        /**
         * Elements are either in the unnamed module, or are in no module,
         * to be found on the source path, class path, and so on.
         */
        PACKAGE
    }

    /**
     * A class that defines the set of supported options.
     */
    public enum Option {
        /**
         * {@code --api} <var>name</var>.
         *
         * <p>The option should be followed by any API-specific configuration options in the
         * arguments that immediately follow this option.
         */
        API("--api", "opt.arg.api") {
            @Override
            void process(String opt, String arg, Options options) {
                options.currAPIOptions = options.allAPIOptions.computeIfAbsent(arg, APIOptions::new);
                options.apiOption = true;
            }
        },

        /**
         * {@code --api-directory} <var>directory</var>.
         *
         * <p>This is an API-specific option. .
         */
        API_DIR("--api-directory", "opt.arg.api-directory") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                Path p = asExistingPath(arg);
                options.putAPIOption(opt, a -> a.apiDir = p);
            }
        },

        /**
         * {@code --class-path} <var>path</var>.
         *
         * <p>This is an API-specific option. See the {@code javac} documentation for details.
         */
        CLASS_PATH("--class-path", "opt.arg.class-path") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));
            }
        },

        /**
         * {@code --compare-api-descriptions} <var>boolean-value</var>
         */
        COMPARE_API_DESCRIPTIONS("--compare-api-descriptions", "opt.arg.boolean") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.compareApiDescriptions = asBoolean(arg);
            }
        },

        /**
         * {@code --compare-api-descriptions-as-text} <var>boolean-value</var>
         */
        COMPARE_API_DESCRIPTIONS_AS_TEXT("--compare-api-descriptions-as-text", "opt.arg.boolean") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.compareApiDescriptionsAsText = asBoolean(arg);
                if (options.compareApiDescriptionsAsText) {
                    options.compareApiDescriptions = true;
                }
            }
        },

        /**
         * {@code --compare-doc-comments} <var>boolean-value</var>
         */
        COMPARE_DOC_COMMENTS("--compare-doc-comments", "opt.arg.boolean") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.compareDocComments = asBoolean(arg);
            }
        },

        /**
         * {@code --enable-preview}.
         *
         * <p>This is an API-specific option. See the {@code javac} documentation for details.
         */
        ENABLE_PREVIEW("--enable-preview", null) {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.putAPIOption(opt, a -> a.enablePreview = true);
            }
        },

        /**
         * {@code --label} <var>text</var>.
         *
         * <p>This is an API-specific option. .
         */
        LABEL("--label", "opt.arg.plain-text") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.putAPIOption(opt, a -> a.label = arg);
            }
        },

        /**
         * {@code --module-path} <var>path</var>.
         *
         * <p>This is an API-specific option. See the {@code javac} documentation for details.
         */
        MODULE_PATH("--module-path", "opt.arg.module-path") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));
            }
        },

        /**
         * {@code --module-source-path} <var>pattern-or-module-specific-path</var>.
         *
         * <p>This is an API-specific option. See the {@code javac} documentation for details.
         */
        MODULE_SOURCE_PATH("--module-source-path", "opt.arg.module-source-path")  {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));
            }
        },

        /**
         * {@code --module-path} <var>module-specific-path</var>.
         *
         * <p>This is an API-specific option. See the {@code javac} documentation for details.
         */
        PATCH_MODULE("--patch-module", "opt.arg.patch-module") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));
            }
        },

        /**
         * {@code --release} <var>release</var>.
         *
         * <p>This is an API-specific option. See the {@code javac} documentation for details.
         */
        RELEASE("--release", "opt.arg.jdk-version") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.putAPIOption(opt, a -> a.release = arg);
            }
        },

        /**
         * {@code --source} <var>release</var>.
         *
         * <p>This is an API-specific option. See the {@code javac} documentation for details.
         */
        SOURCE("--source", "opt.arg.jdk-version") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.putAPIOption(opt, a -> a.source = arg);
            }
        },

        /**
         * {@code --source-path} <var>path</var>.
         *
         * <p>This is an API-specific option. See the {@code javac} documentation for details.
         */
        SOURCE_PATH("--source-path", "opt.arg.source-path") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));
            }
        },

        /**
         * {@code --system} <var>jdk</var>.
         *
         * <p>This is an API-specific option. See the {@code javac} documentation for details.
         */
        SYSTEM("--system", "opt.arg.jdk-home") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));
            }
        },

        /**
         * {@code --jdk-build} <var>build-directory</var>
         *
         * Shorthand for a series of API-specific options that can be derived from the
         * location of a JDK build.
         */
        JDK_BUILD("--jdk-build", "opt.arg.jdk-build") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                Path jdkBuildDir = asExistingPath(arg);
                options.putAPIOption(opt, a -> a.jdkBuildDir = jdkBuildDir);
            }
        },

        /**
         * {@code --jdk-docs} <var>docs-directory-name</var>
         *
         * Used with {@code --jdk-build} to specify the name of the docs directory.
         */
        JDK_DOCS("--jdk-docs", "opt.arg.jdk-docs") {
            @Override
            void process(String opt, String arg, Options options) {
                options.jdkDocs = arg;
            }
        },

        // Selection options

        /**
         * {@code --access} {@code }public|protected|package|private}.
         *
         * <p>Specifies the access level of items to be compared.
         * The default is {@code protected}.
         */
        ACCESS("--access", "opt.arg.access") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.access = switch (arg) {
                    case "public" -> AccessKind.PUBLIC;
                    case "protected" -> AccessKind.PROTECTED;
                    case "package" -> AccessKind.PACKAGE;
                    case "private" -> AccessKind.PRIVATE;
                    default -> throw new BadOption("options.err.bad-access", arg);
                };
            }
        },

        /**
         * {@code --exclude} <var>pattern</var>.
         *
         * <p>Specify patterns for elements to be excluded from the comparison.
         */
        EXCLUDE("--exclude", "opt.arg.pattern") {
            @Override
            void process(String opt, String arg, Options options) {
                options.excludes.add(arg);
            }
        },

        /**
         * {@code --include} <var>pattern</var>.
         *
         * <p>Specify patterns for elements to be included in the comparison.
         */
        INCLUDE("--include", "opt.arg.pattern") {
            @Override
            void process(String opt, String arg, Options options) {
                options.includes.add(arg);
            }
        },

        // Output options

        /**
         * {@code --output-directory} <var>dir</var>.
         *
         * <p>The directory in which to generate the comparison report.
         */
        OUTDIR("--output-directory -d", "opt.arg.directory") {
            @Override
            void process(String opt, String arg, Options options) {
                options.outDir = Path.of(arg);
            }
        },

        /**
         * {@code --title} <var>string</var>.
         *
         * <p>A plain-text title for the report.
         */
        TITLE("--title", "opt.arg.plain-text") {
            @Override
            void process(String opt, String arg, Options options) {
                options.title = arg;
            }
        },

        /**
         * {@code --description} <var>html-text</var>.
         *
         * <p>A description to be included in the report.
         */
        DESCRIPTION("--description", "opt.arg.html-text") {
            @Override
            void process(String opt, String arg, Options options) {
                options.description = arg;
            }
        },

        /**
         * {@code --info-text}  <var>place-list</var>{@code =}<var>html-text</var>.
         *
         * <p>Additional text to be included in one or more of the top, header, footer or bottom
         * of the page. The option may be given more than once, but at most once for any one
         * position.
         */
        INFO_TEXT("--info-text", "opt.arg.info-text") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                int eq = arg.indexOf('=');
                if (eq == -1) {
                    throw new BadOption("options.err.invalid.info.text");
                }
                String[] keys = arg.substring(0, eq).split(",");
                for (String k : keys) {
                    try {
                        InfoTextKind kind = InfoTextKind.valueOf(k.toUpperCase(Locale.ROOT));
                        options.infoText.put(kind, arg.substring(eq + 1));
                    } catch (IllegalArgumentException e) {
                        throw new BadOption("options.err.invalid-info-text-kind", k);
                    }
                }
            }
        },

        /**
         * {@code --notes} <var>notes-file</var>
         *
         * <p>Details of notes (links) to be associated with various individual elements.</p>
         */
        NOTES("--notes", "opt.arg.file") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.notes = asExistingPath(arg);
            }
        },

        /**
         * {@code --main-stylesheet} <var>file</var>
         *
         * <p>Specify an alternative default stylesheet.
         */
        MAIN_STYLESHEET("--main-stylesheet", "opt.arg.file") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                options.mainStylesheet = asExistingPath(arg);
            }

        },

        /**
         * {@code --extra-stylesheet} <var>file</var>
         *
         * <p>Specify an additional stylesheet.
         */
        EXTRA_STYLESHEET("--extra-stylesheet", "opt.arg.file") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                if (options.extraStylesheets == null) {
                    options.extraStylesheets = new ArrayList<>();
                }
                options.extraStylesheets.add(asExistingPath(arg));
            }

        },

        /**
         * {@code --resource-files} <var>file</var>
         *
         * <p>Specify additional resource files to be included in the output.
         */
        RESOURCE_FILES("--resource-files", "opt.arg.file-or-directory") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                if (options.resourceFiles == null) {
                    options.resourceFiles = new ArrayList<>();
                }
                options.resourceFiles.add(asPath(arg));
            }

        },


        // Help and information options

        /**
         * {@code --help}.
         *
         * <p>Show command line help.
         */
        HELP("--help -h -help -?", null) {
            @Override
            void process(String opt, String arg, Options options) {
                options.help = true;
            }
        },

        /**
         * {@code --version}.
         *
         * <p>Show the version of the program.
         */
        VERSION("--version -v", null) {
            @Override
            void process(String opt, String arg, Options options) {
                options.version = true;
            }
        },

        /**
         * {@code --verbose [flag|-flag|all|none]*}.
         *
         * <p>Specify the verbosity of the program.
         */
        VERBOSE("--verbose", "opt.arg.verbose") {
            @Override
            void process(String opt, String arg, Options options) throws BadOption {
                for (String a : arg.split(",+")) {
                    switch (a) {
                        case "all" ->
                            options.verboseKinds.addAll(EnumSet.allOf(VerboseKind.class));

                        case "none" ->
                            options.verboseKinds.clear();

                        default -> {
                            String name;
                            boolean clear = false;
                            if (a.startsWith("-")) {
                                clear = true;
                                name = a.substring(1);
                            } else {
                                name = a;
                            }
                            try {
                                VerboseKind k = VerboseKind.valueOf(name.toUpperCase(Locale.ROOT));
                                if (clear) {
                                    options.verboseKinds.remove(k);
                                } else {
                                    options.verboseKinds.add(k);
                                }
                            } catch (IllegalArgumentException e) {
                                throw new BadOption("options.err.invalid-arg-for-verbose", a);
                            }
                        }
                    }
                }
            }
            @Override
            public String getHelpDescription(Messages msgs, String key) {
                String flags = Arrays.stream(VerboseKind.values())
                        .map(k -> k.name().toLowerCase(Locale.ROOT))
                        .collect(Collectors.joining(" "));
                return msgs.getString(key, flags);
            }
        };

        final List<String> names;
        final String arg;

        Option(String names, String arg) {
            this.names = Arrays.asList(names.split("\\s+"));
            this.arg = arg;
        }

        abstract void process(String opt, String arg, Options options) throws BadOption;

        /**
         * Returns the list of names for the option.
         *
         * @return the names
         */
        public List<String> getNames() {
            return names;
        }

        /**
         * Returns the resource key for the argument accepted by the option,
         * or {@code null} if the option does not take an argument.
         *
         * @return the resource key
         */
        public String getArg() {
            return arg;
        }

        /**
         * Returns the description for an option, based on a resource key.
         *
         * @param msgs the messages to be used to generate the description
         * @param key  the resource key
         *
         * @return the description
         */
        public String getHelpDescription(Messages msgs, String key) {
            return msgs.getString(key);
        }

        private static boolean asBoolean(String arg) throws BadOption {
            return switch (arg.toLowerCase(Locale.ROOT)) {
                case "true", "yes", "on" -> true;
                case "false", "no", "off" -> false;
                default -> throw new BadOption("options.err.invalid-boolean", arg);
            };
        }
    }

    Options(Log log, List<String> args) {
        // @files should have already been processed

        this.log = log;

        Map<String, Option> map = new HashMap<>();
        for (Option o : Option.values()) {
            o.names.forEach(n -> map.put(n, o));
        }

        // TODO: convert to use Iterator or ListIterator
        for (int i = 0; i < args.size(); i++) {
            String arg = args.get(i);
            // currently no support for positional args
            String optName, optValue;
            int eq = arg.startsWith("--") ? arg.indexOf("=") : -1;
            if (eq == -1) {
                optName = arg;
                optValue = null;
            } else {
                optName = arg.substring(0, eq);
                optValue = arg.substring(eq + 1);
            }
            if (optName.isEmpty()) {
                log.error("options.err.bad.argument", arg);
            } else {
                Option opt = map.get(optName);
                if (opt == null) {
                    if (optName.startsWith("-XD")) {
                        setHiddenOption(optName.substring(3));
                    } else {
                        reportBadOption(optName);
                    }
                } else {
                    apiOption = false;
                    try {
                        if (opt.arg == null) {
                            // no value for option required
                            if (optValue != null) {
                                log.error("options.err.unexpected-value-for-option", optName, optValue);
                            } else {
                                opt.process(optName, null, this);
                            }
                        } else {
                            // value for option required; use next arg if not found after '='
                            if (optValue == null) {
                                if (i + 1 < args.size()) {
                                    optValue = args.get(++i);
                                } else {
                                    log.error("options.err.missing-value-for-option", optName);
                                    continue;
                                }
                            }
                            opt.process(optName, optValue, this);
                        }
                    } catch (BadOption e) {
                        log.error(e.key, e.args);
                    }
                    // Cancel the "API options mode" when a non-API option is used.
                    if (!apiOption) {
                        currAPIOptions = null;
                    }
                }
            }
        }
    }

    private void reportBadOption(String name) {
        log.error("options.err.unknown-option", name);

        var allOptionNames = Stream.of(Option.values())
                .flatMap(o -> o.getNames().stream());
        record Pair(String word, double similarity) { }
        final double MIN_SIMILARITY = 0.7;
        var suggestions = allOptionNames
                .map(t -> new Pair(t, similarity(t, name)))
                .sorted(Comparator.comparingDouble(Pair::similarity).reversed() /* more similar first */)
                // .peek(p -> System.out.printf("%.3f, (%s ~ %s)%n", p.similarity, p.word, name)) // debug
                .takeWhile(p -> Double.compare(p.similarity, MIN_SIMILARITY) >= 0)
                .map(Pair::word)
                .toList();
        switch (suggestions.size()) {
            case 0 -> { }
            case 1 -> log.report("options.did-you-mean", suggestions.get(0));
            default -> log.report("options.did-you-mean-one-of", String.join(" ", suggestions));
        }
        log.report("options.for-more-details-see-usage");
    }

    // a value in [0, 1] range: the closer the value is to 1, the more similar
    // the strings are
    private static double similarity(String a, String b) {
        // Normalize the distance so that similarity between "x" and "y" is
        // less than that of "ax" and "ay". Use the greater of two lengths
        // as normalizer, as it's an upper bound for the distance.
        return 1.0 - ((double) DamerauLevenshteinDistance.of(a, b))
                / Math.max(a.length(), b.length());
    }

    /**
     * Returns the collection of API options.
     *
     * @return the collection of API options
     */
    public Map<String, APIOptions> getAllAPIOptions() {
        return allAPIOptions;
    }

    /**
     * Returns the mode for the comparison.
     *
     * @return the mode for the comparison
     */
    public Mode getMode() {
        return includes.isEmpty()
                ? null
                : includes.get(0).contains("/") ? Mode.MODULE : Mode.PACKAGE;
    }

    /**
     * Returns the access kind to be used to select items to be compared.
     * If a value was not specified in the options provided to the constructor,
     * a default value of {@code PROTECTED} is returned.
     *
     * @return the access
     */
    public AccessKind getAccessKind() {
        return access != null ? access : AccessKind.PROTECTED;
    }

    /**
     * Returns whether API descriptions should be compared.
     *
     * @return {@code true} if API descriptions should be compared
     */
    public boolean compareApiDescriptions() {
        return compareApiDescriptions;
    }

    /**
     * Returns whether API descriptions should be compared as plain text.
     *
     * @return {@code true} if API descriptions should be compared as plain text
     */
    public boolean compareApiDescriptionsAsText() {
        return compareApiDescriptionsAsText;
    }

    /**
     * Returns whether documentation comments should be compared.
     *
     * @return {@code true} if documentation comments should be compared
     */
    public boolean compareDocComments() {
        return compareDocComments;
    }

    /**
     * Returns the output directory to be used.
     *
     * @return the output directory
     */
    public Path getOutDir() {
        return outDir;
    }

    /**
     * Returns the title for the report.
     *
     * @return the title
     */
    public String getTitle() {
        return title;
    }

    /**
     * Returns the description for the report.
     *
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns the additional text for the report.
     * @param kind the kind of the text
     * @return the text
     */
    public String getInfoText(InfoTextKind kind) {
        return infoText.get(kind);
    }

    /**
     * Returns the user-specified main stylesheet for the report.
     *
     * @return the stylesheet
     */
    public Path getMainStylesheet() {
        return mainStylesheet;
    }

    /**
     * Returns any user-specified additional stylesheets for the report.
     *
     * @return the stylesheets
     */
    public List<Path> getExtraStylesheets() {
        return (extraStylesheets == null) ? Collections.emptyList() : extraStylesheets;
    }

    /**
     * Returns any user-specified additional stylesheets for the report.
     *
     * @return the stylesheets
     */
    public List<Path> getResourceFiles() {
        return (resourceFiles == null) ? Collections.emptyList() : resourceFiles;
    }

    public boolean showEqual() {
        return showEqual;
    }

    /**
     * Returns the value of a "hidden" option, set by {@code -XD<name>} or
     * {@code -XD<name>=<value>}.
     *
     * @param name the name of the hidden option
     * @return the value of the option, or null if not set
     */
    public String getHiddenOption(String name) {
        return hidden.get(name);
    }

    /**
     * Returns whether a kind of verbose mode is enabled.
     * @param k the kind of verbose mode
     * @return {@code true} if a kind of verbose mode is enabled
     */
    public boolean isVerbose(VerboseKind k) {
        return verboseKinds.contains(k);
    }

    void putAPIOption(String optName, Consumer<APIOptions> f) throws BadOption {
        if (currAPIOptions == null) {
            throw new BadOption("options.err.no-api-for-option", optName);
        }
        apiOption = true;
        f.accept(currAPIOptions);
    }

    void setHiddenOption(String s) {
        int eq = s.indexOf('=');
        if (eq == -1) {
            hidden.put(s, s);
        } else {
            hidden.put(s.substring(0, eq), s.substring(eq + 1));
        }
    }

    static Path asPath(String p) throws BadOption {
        try {
            return Path.of(p);
        } catch (InvalidPathException e) {
            throw new BadOption("options.err.bad-file", p);
        }
    }

    static Path asExistingPath(String p) throws BadOption {
        try {
            Path path = Path.of(p);
            if (!Files.exists(path)) {
                throw new BadOption("options.err.file-not-found", p);
            }
            return path;
        } catch (InvalidPathException e) {
            throw new BadOption("options.err.bad-file", p);
        }
    }

    void validate() {
//        // fixme?
//        // check not package and module paths for different APIs
//        // check not mixed modes for different APIs
//
        // Check at least one includes option
        if (includes.isEmpty()) {
            log.error("options.err.no-include-options");
        } else {
            Mode mode = getMode();
            includes.forEach(s -> checkPattern(mode, s));
            excludes.forEach(s -> checkPattern(mode, s));
        }

        allAPIOptions.values().forEach(this::checkAPIOptions);
        if (log.errorCount() > 0) {
            return;
        }

        boolean allApiHaveApiDir = allAPIOptions.values().stream().allMatch(a -> a.apiDir != null);
        if (compareApiDescriptions == null) {
            // if not specified explicitly, compare API descriptions if not comparing doc comments
            // and if --api-directory is specified for all API instances
            compareApiDescriptions = (compareDocComments != Boolean.TRUE) && allApiHaveApiDir;
        } else {
            // if specified, check --api-directory is specified for all API instances
            if (compareApiDescriptions && !allApiHaveApiDir) {
                log.error("options.err.compare-api-but-missing-dir");
            }
        }

        if (compareApiDescriptionsAsText == null) {
            compareApiDescriptionsAsText = false;
        }

        if (compareDocComments == null) {
            // if not specified explicitly, compare doc comments if not comparing API descriptions
            compareDocComments = !compareApiDescriptions;
        }

        if (resourceFiles != null) {
            for (var resFile : resourceFiles) {
                if (resFile.isAbsolute() && !Files.exists(resFile)) {
                    // if it is an absolute path and doesn't exist,
                    // report error, no need to check further
                    log.error("options.err.resource-file-not-found", resFile);
                } else {
                    // otherwise check that the file is in at least one api directory
                    boolean found = false;
                    for (var apiOpts : allAPIOptions.values()) {
                        var apiDir = apiOpts.apiDir;
                        if (apiDir != null) {
                            var absApiDir = apiDir.toAbsolutePath();
                            if (resFile.isAbsolute() && resFile.startsWith(absApiDir)
                                    || Files.exists(absApiDir.resolve(resFile))) {
                                found = true;
                                break;
                            }
                        }
                    }
                    if (!found) {
                        log.error("options.err.resource-file-not-found-in-api-dirs", resFile);
                    }
                }
            }
        }
    }

    private void checkAPIOptions(APIOptions apiOptions) {
        if (apiOptions.jdkBuildDir != null) {
            Path dir = apiOptions.jdkBuildDir;
            if (!Files.exists(dir.resolve("spec.gmk"))) {
                log.error("options.err.bad-jdk-build-dir", apiOptions.name, dir);
            } else if (!Files.exists(dir.resolve("images"))) {
                log.error("options.err.no-images-in-jdk-build-dir", apiOptions.name, dir);
            } else {
                JDKBuildOption o = new JDKBuildOption(apiOptions.jdkBuildDir);
                o.expand(this, apiOptions, log);
            }
        }
    }

    private void checkPattern(Mode mode, String arg) {
        String s = arg;
        int slash = s.indexOf("/");
        if (slash == -1) {
            if (mode == Mode.MODULE) {
                log.error("options.err.missing-module-name", arg);
            }
        } else {
            String mdl = s.substring(0, slash);
            if (mdl.endsWith(".*")) {
                mdl = mdl.substring(0, mdl.length() - 2);
            }
            if (mdl.isEmpty()) {
                log.error("options.err.empty-module-name", arg);
            } else if (!SourceVersion.isName(mdl, SourceVersion.latestSupported())) {
                log.error("options.err.bad-module-name", arg);
            } else if (mode == Mode.PACKAGE) {
                log.error("options.err.unexpected-module-name", arg);
            }
            s = s.substring(slash + 1);
        }

        if (s.equals("**")) {
            if (mode == Mode.PACKAGE) {
                log.error("options.err.bad-package-name", arg);
            }
        } else {
            String pkg;
            if (s.endsWith(".*")) {
                pkg = s.substring(0, s.length() - 2);
            } else if (s.endsWith(".**")) {
                pkg = s.substring(0, s.length() - 3);
            } else {
                pkg = s;
            }
            if (pkg.isEmpty()) {
                if (mode == Mode.PACKAGE) {
                    log.error("options.err.empty-package-name", arg);
                }
            } else if (!SourceVersion.isName(pkg, SourceVersion.latestSupported())) {
                log.error("options.err.bad-package-name", arg);
            }
        }
    }

    private SourceVersion getSourceVersion(String v) {
        switch (v) {
            case "1.6", "1.7", "1.8", "1.9", "1.10" -> v = v.substring(2);
        }
        try {
            return SourceVersion.valueOf("RELEASE_" + v);
        } catch (IllegalArgumentException e) {
            log.error("options.err.bad-source", v);
            return SourceVersion.latest();
        }
    }

    void showHelp() {
        Messages messages = Messages.instance("jdk.codetools.apidiff.resources.help");
        PrintWriter out = log.out;
        String header = messages.getString("options.usage.header");
        header.lines().forEach(out::println);
        for (Option o: Option.values()) {
            String argText = o.arg == null ? null : messages.getString(o.arg);
            String first = "";
            for (String name : o.names) {
                if (first.isEmpty()) {
                    first = name;
                } else {
                    out.print(", ");
                }
                out.print(" " + name);
                if (argText != null) {
                    log.out.print(" ");
                    log.out.print(argText);
                }
            }
            out.println();
            String helpTextKey = "opt.desc." + first.replaceAll("^-+", "")
                    .replaceAll("(?i)[^A-Z0-9-]+", ".");
            String helpText = o.getHelpDescription(messages, helpTextKey);
            helpText.lines().forEach(l -> out.println("    " + l));
        }
    }

}
