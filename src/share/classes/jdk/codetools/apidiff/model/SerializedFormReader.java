/*
 * Copyright (c) 2019, 2023, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package jdk.codetools.apidiff.model;

import java.nio.file.Path;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import jdk.codetools.apidiff.Log;

/**
 * A reader that reads the descriptions for the serialized forms of types,
 * from the serialized-form.html file generated by javadoc.
 *
 * <p>The output generated by javadoc is not well-specified and varies across releases.
 * The following rules allow fuzzy parsing for at least JDK version 11 and later.
 *
 * <ul>
 * <li>The details for a type are introduced by a heading beginning "Class name".
 *
 * <li>The serialVersionUID is contained in a definition list:
 *     {@code <dt>serialVersionUID:</dt><dd>the-value</dd>}
 *
 * <li>The serialization overview is introduced by a heading "Serialization Overview".
 *     The description begins after the following {@code <li>} and ends at the
 *     corresponding {@code </li>}.
 *
 * <li>The serialized fields are introduced by a heading "Serialized Fields".
 *     The individual fields are introduced by headings containing the name of the field.
 *     The description of the field begins after the {@code <pre>} containing the
 *     signature, and ends before the enclosing {@code </li>}.
 *
 * <li>The serialization methods are introduced by a heading "Serialization Methods".
 *     The individual methods are introduced by headings containing the name of the method.
 *     The description of the method begins after the {@code <pre>} containing the
 *     signature, and ends before the enclosing {@code </li>}.
 * </ul>
 *
 * The descriptions for a type end when the heading for the next type is seen,
 * or when {@code </main>} is read.
 */
public class SerializedFormReader extends HtmlParser {
    private final Log log;
    private Map<String, SerializedFormDocs> allDocs;

    /**
     * Creates a reader.
     *
     * @param log a log to which to report any errors.
     */
    SerializedFormReader(Log log) {
        this.log = log;
    }

    // TEMPORARY!
    boolean debug = false;
    private void debugPrintln(Supplier<String> s) {
        if (debug) {
            System.err.println(s.get());
        }
    }

    @Override
    public void read(Path file) {
        allDocs = new LinkedHashMap<>();
        super.read(file);
    }

    /**
     * Returns the collection of descriptions found during a preceding call
     * of {@code read}.
     * The descriptions are indexed by the name of the corresponding type.
     *
     * @return the descriptions.
     */
    Map<String, SerializedFormDocs> getSerializedFormDocs() {
        return allDocs;
    }

    @Override
    protected void error(Path file, int lineNumber, String message) {
        log.err.println(file + ":" + lineNumber + ": " + message);
    }

    @Override
    protected void error(Path file, int lineNumber, Throwable t) {
        log.err.println(file + ":" + lineNumber + ": " + t);
    }

    private StringBuilder contentBuffer;
    private boolean inMain;
    private int startElementIndex;
    private int startDescriptionIndex;
    private boolean inDescription;
    private boolean inMemberSignature;
    private int ulDepth;

    /**
     * An indication of the position of the parser.
     */
    private enum State {
        /**
         * Before any types have been detected.
         * It transitions to {@code TYPE} when the heading for a type is found.
         */
        INIT,
        /**
         * Within the details for a type, but not in any specific part of the type.
         * The state is entered when the heading for a type is found.
         */
        TYPE,
        /**
         * Within the details for the serial version UID.
         * The state is entered when the heading for the {@code serialVersionUID} is found,
         * and reverts to {@code TYPE} when the description has been read.
         */
        SERIAL_VERSION_UID,
        /**
         * Within the details for the serialization overview.
         * The state is entered when the heading for the serialization overview is found,
         * and reverts to {@code TYPE} when the description has been read.
         */
        OVERVIEW,
        /**
         * Within the details for the serialized fields, but not in any specific field.
         * The state is entered when the heading for the serialized fields is found,
         * and will typically progress to progress to {@code FIELD}, {@code METHODS},
         * or {@code TYPE}, depending on which kind of heading is found.
         */
        FIELDS,
        /**
         * Within the details for a specific serialized field.
         * The state is entered when the heading for a specific serialized field is found,
         * and reverts to {@code FIELDS} when the description has been read.
         */
        FIELD,
        /**
         * Within the details for the serialization methods, but not in any specific method.
         * The state is entered when the heading for the serialization methods is found,
         * and will typically progress to {@code METHOD} or {@code TYPE}, depending on
         * which kind of heading is found. In practice,
         */
        METHODS,
        /**
         * Within the details for a specific serialization method.
         * The state is entered when the heading for a specific serialization method is found,
         * and reverts to {@code METHODS} when the description has been read.
         */
        METHOD
    }
    private State state;

    /**
     * The name of the current type, determined by the heading beginning {@code Class <name>}.
     */
    private String currType;

    /**
     * The name of the current field or method.
     */
    private String currMember;

    /**
     * The serialVersionUID.
     */
    private String serialVersionUID;

    /**
     * The serialization overview.
     */
    private String overview;

    /**
     * The collection of descriptions for the serialized fields of the current type.
     */
    private Map<String, String> fieldDescriptions;

    /**
     * The collection of descriptions for the serialization methods of the current type.
     */
    private Map<String, String> methodDescriptions;

    @Override
    protected void content(Supplier<String> content) {
        if (contentBuffer != null) {
            contentBuffer.append(content.get());
        }
    }

    @Override
    protected void html() {
        startElementIndex = getBufferIndex() - 1;
        super.html();
    }

    @Override
    protected void startElement(String name, Map<String, String> attrs, boolean selfClosing) {
        // skip everything not in the `<main>` element
        if (!inMain) {
            if (name.equals("main")) {
                inMain = true;
                state = State.INIT;
            }
            return;
        }

        debugPrintln(() -> "    <" + name + " " + attrs + "> " + state + " " + inDescription + " " + ulDepth);

        switch (name) {
            case "dt":
            case "dd":
            case "h2": case "h3": case "h4": case "h5":
                if (!inDescription) {
                    contentBuffer = new StringBuilder();
                }
                break;

            case "div":
                String cssClass = attrs.get("class");
                if (cssClass != null && cssClass.matches("member(S|-s)ignature")) {
                    inMemberSignature = true;
                }
                break;

            case "li":
                if (state == State.OVERVIEW && !inDescription) {
                    debugPrintln(() -> "start description for " + state + " after start " + name);
                    inDescription = true;
                    startDescriptionIndex = getBufferIndex();
                    ulDepth = 0;
                }
                break;

            case "ul":
                if (inDescription) {
                    ulDepth++;
                }
                break;
        }
    }

    private final Pattern classPtn = Pattern.compile("(?i)(Class|Exception|Record)(\\s|&nbsp;)++(?<name>\\S+).*");

    @Override
    protected void endElement(String name) {
        // skip everything not in the `<main>` element
        if (!inMain) {
            return;
        }

        debugPrintln(() -> "    </" + name + "> " + state + " " + inDescription + " " + ulDepth);

        switch (name) {
            case "dt":
                if (!inDescription && contentBuffer.toString().equals("serialVersionUID:")) {
                    state = State.SERIAL_VERSION_UID;
                }
                break;

            case "dd":
                if (!inDescription && state == State.SERIAL_VERSION_UID) {
                    serialVersionUID = contentBuffer.toString();
                    state = State.TYPE;
                }
                break;

            case "h2": case "h3": case "h4": case "h5":
                if (inDescription) {
                    break;
                }

                String content = contentBuffer.toString();
                contentBuffer = null;

                switch (content) {
                    case "Serialized Fields":
                        state = State.FIELDS;
                        break;

                    case "Serialization Methods":
                        state = State.METHODS;
                        break;

                    case "Serialization Overview":
                        state = State.OVERVIEW;
                        break;

                    default:
                        if (ulDepth == 0) {
                            Matcher m = classPtn.matcher(content);
                            if (m.matches()) {
                                if (currType != null) {
                                    saveCurrentDocs();
                                }
                                debugPrintln(() -> "START TYPE " + m.group("name"));
                                state = State.TYPE;
                                currType = m.group(1);
                                serialVersionUID = null;
                                overview = null;
                                fieldDescriptions = Collections.emptyMap();
                                methodDescriptions = Collections.emptyMap();
                            } else {
                                switch (state) {
                                    case FIELDS -> {
                                        debugPrintln(() -> "START " + state + " " + content);
                                        currMember = content;
                                        state = State.FIELD;
                                    }
                                    case METHODS -> {
                                        debugPrintln(() -> "START " + state + " " + content);
                                        currMember = content;
                                        state = State.METHOD;
                                    }
                                }
                            }
                        }
                }
                debugPrintln(() -> "Finished heading " + name + " " + state + ": " + content);
                break;

            case "li":
                if (inDescription && ulDepth == 0) {
                    String d = getTrimBufferString(startDescriptionIndex, startElementIndex);
                    switch (state) {
                        case FIELD -> {
                            fieldDescriptions = saveMember(fieldDescriptions, d);
                            state = State.FIELDS;
                        }
                        case METHOD -> {
                            methodDescriptions = saveMember(methodDescriptions, d);
                            state = State.METHODS;
                        }
                        case OVERVIEW -> {
                            overview = d;
                            state = State.TYPE;
                        }
                    }
                    debugPrintln(() -> "end description " + state + " " + currMember + " " + d);
                    inDescription = false;
                }
                break;

            case "main":
                saveCurrentDocs();
                debugPrintln(() -> "Docs for " + allDocs.keySet());
                inMain = false;
                break;

            case "pre":
                switch (state) {
                    case FIELD:
                    case METHOD:
                        if (!inDescription) {
                            debugPrintln(() -> "start description for " + state + " after end " + name);
                            inDescription = true;
                            startDescriptionIndex = getBufferIndex();
                            ulDepth = 0;
                        }
                }
                break;

            case "div":
                if (inMemberSignature) {
                    debugPrintln(() -> "start description for " + state + " after end " + name);
                    inMemberSignature = false;
                    inDescription = true;
                    startDescriptionIndex = getBufferIndex();
                    ulDepth = 0;
                }
                break;

            case "ul":
                if (inDescription) {
                    ulDepth--;
                }
                break;
        }
    }

    private Map<String, String> saveMember(Map<String, String> descriptions, String d) {
        if (descriptions.isEmpty()) {
            // replace the shared empty map with an unshared mutable map
            descriptions = new HashMap<>();
        }

        descriptions.put(currMember, d);

        return descriptions;
    }

    private void saveCurrentDocs() {
        if (currType != null) {
            if (debug) {
                debugPrintln(() -> "SAVE type " + currType);
                fieldDescriptions.forEach((f, d) -> debugPrintln(() -> "SAVE field " + f + ": " + d));
                methodDescriptions.forEach((m, d) -> debugPrintln(() -> "SAVE method " + m + ": " + d));
                debugPrintln(() -> "SAVE overview " + overview);
            }
            allDocs.put(currType,
                    new SerializedFormDocs(serialVersionUID, overview, fieldDescriptions, methodDescriptions));
            currType = null;
        }
    }
}
