/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package jdk.codetools.apidiff.model;

import java.nio.file.Path;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import jdk.codetools.apidiff.Log;

/**
 * A reader that reads descriptions for program elements from HTML files generated by javadoc.
 * Only files in HTML5 format are supported: the primary reason being the lossy-encoding
 * of member signatures into {@code name} attributes in HTML4 files.
 *
 * The output generated by javadoc is not well-specified and varies across releases.
 * The following rules allow fuzzy parsing for at least JDK version 11 and later.
 *
 * <ul>
 * <li> For a module, the description is the smallest enclosing {@code <section>} containing
 *      {@code id="module-description"} or {@code id="module.description"}, or the {@code <div>}
 *      within that section. It may be followed by an additional {@code <section>} containing
 *      the block tags for the description.
 *
 * <li> For a package, the description is the smallest enclosing {@code <section>} containing
 *      {@code id="package-description"} or {@code id="package.description"}, or the {@code <div>}
 *      within that section.
 *
 * <li> For a type, the description is the enclosing
 *      {@code <div id="class-description" class="class-description">} or
 *      {@code <div class="description">},
 *      or the {@code <div>} within that section.
 *
 * <li> For a member, the description follows the "...Detail" heading, then an
 *      {@code id="signature"}, then a heading and a subsequent {@code <div>}.
 *      There may be enclosing {@code <ul>} and {@code <li>} nodes to be taken into
 *      account, for older versions of javadoc.  There is an enclosing {@code <div>}
 *      we could select as well. Note the heading has an incomplete signature;
 *      the preceding {@code id} is more accurate.
 * </ul>
 */
public class APIReader extends HtmlParser {
    private enum Kind { MODULE, PACKAGE, TYPE }

    private final Log log;
    private Kind kind;
    private String description;
    private Map<String, String> memberDescriptions;
    private Map<String, String> declarationNames;

    APIReader(Log log) {
        this.log = log;
    }

    // TEMPORARY!
    boolean debug = false;
    private void debugPrintln(Supplier<String> s) {
        if (debug) {
            System.err.println(s.get());
        }
    }

    @Override
    public void read(Path file) {
        debug = Objects.equals(file.getFileName().toString(), System.getProperty("debug.APIReader"));
        kind = getKind(file);
        description = null;
        memberDescriptions = new HashMap<>();
        debugPrintln(() -> "**************************************** read " + file + " " + kind);
        super.read(file);
    }

    /**
     * Returns the parts of the names for the top-level element defined on this page.
     * The keys for the names are {@code module}, {@code package} and {@code class}.
     *
     * @return a map containing the parts of the names
     */
    public Map<String, String> getDeclarationNames() {
        return (declarationNames == null) ? Collections.emptyMap() : declarationNames;
    }

    /**
     * Returns the main description of the primary element declared on this page.
     *
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a map containing the descriptions of the member elements enclosed by the
     * primary element declared on the page.
     * The keys of the map are the signatures of the individual members.
     *
     * @return the map
     */
    public Map<String, String> getMemberDescriptions() {
        return memberDescriptions;
    }

    @Override
    protected void error(Path file, int lineNumber, String message) {
        log.err.println(file + ":" + lineNumber + ": " + message);
    }

    @Override
    protected void error(Path file, int lineNumber, Throwable t) {
        log.err.println(file + ":" + lineNumber + ": " + t);
    }

    private StringBuilder contentBuffer;
    private boolean inMain;
    private int startDescriptionIndex;
    private boolean inDescription;
    private String descriptionId;
    private int blockDepth;
    private boolean inDetails;
    private boolean inHeader;
    private boolean inSubTitle;
    private String detailHeading;
    private boolean allowMoreModuleSections;

    @Override
    protected void content(Supplier<String> content) {
        if (contentBuffer != null) {
            contentBuffer.append(content.get());
        }
    }

    @Override
    protected void html() {
        if (startDescriptionIndex == -1) {
            startDescriptionIndex = getBufferIndex() - 1;
        }
        super.html();
        if (!inDescription) {
            startDescriptionIndex = -1;
        }
    }

    @Override
    protected void startElement(String name, Map<String, String> attrs, boolean isSelfClosing) {
        // skip almost everything not in the `<main>` element
        if (!inMain) {
            switch (name) {
                case "meta" -> {
                    String nameAttr = attrs.get("name");
                    String contentAttr = attrs.get("content");
                    if (Objects.equals(nameAttr, "description")
                            && contentAttr != null
                            && contentAttr.startsWith("declaration: ")) {
                        Map<String, String> names = new LinkedHashMap<>();
                        Pattern p = Pattern.compile("(?<key>[a-z]+):\\s+(?<value>[A-Za-z0-9_$.]+)");
                        Matcher m = p.matcher(contentAttr.substring(contentAttr.indexOf(' ')));
                        while (m.find()) {
                            names.put(m.group("key"), m.group("value"));
                        }
                        declarationNames = names;
                    }
                }
                case "main" ->
                    inMain = true;
            }
            return;
        }

        debugPrintln(() -> "<" + name + " " + attrs + ">");
        String classAttr = attrs.get("class");
        switch (name) {
            case "div":
                // For some older versions of javadoc, the description for a type declaration
                // is contained in `<div class="description">...</div>`
                if ((kind == Kind.TYPE) && isClassDescription(attrs)) {
                    debugPrintln(() -> "!! start description for TYPE");
                    inDescription = true;
                    blockDepth = 1;
                } else if (Objects.equals(classAttr, "header")) {
                    inHeader = true;
                } else if (Objects.equals(classAttr, "subTitle")
                        || Objects.equals(classAttr, "sub-title") ) {
                    inSubTitle = true;
                    contentBuffer = new StringBuilder();
                } else {
                    if (inDescription) {
                        blockDepth++;
                    }
                }
                break;

            case "section":
                // For some versions of javadoc, the description for a module or package
                // is contained in a section containing an element with `id` set to
                // `module.description` or `package.description`.  For these,
                // proactively set inDescription, but cancel if the first id is incorrect.
                // For some more recent versions of javadoc, the description for a type
                // is contained in `<section class="description">...</section>`, or
                // `<section class="class-description" id="class-description">...</section>` but
                // note that the section is poorly formed for not having a heading.
                // For some more recent versions of javadoc, the description for a member
                // is contained in `<section class="detail">...</section>`.
                if ((kind == Kind.MODULE || kind == Kind.PACKAGE) && description == null
                        || kind == Kind.MODULE && allowMoreModuleSections) {
                    if (inDescription) {
                        blockDepth++;
                    } else {
                        debugPrintln(() -> "?? start description for MODULE or PACKAGE");
                        inDescription = true;
                        blockDepth = 1;
                    }
                } else if ((kind == Kind.TYPE) && isClassDescription(attrs)) {
                    debugPrintln(() -> "!! start description for TYPE");
                    inDescription = true;
                    blockDepth = 1;
                } else if ((kind == Kind.TYPE) && Objects.equals(classAttr, "detail")) {
                    debugPrintln(() -> "!! start description for TYPE member");
                    inDescription = true;
                    blockDepth = 1;
                }
                debugPrintln(() -> ">>>>>> in section " + inDescription + " " + blockDepth);
                break;

            // For some versions of javadoc, the description for a member starts in the
            // details section, with a heading of the appropriate rank.  By itself,
            // the content of the heading does not fully identify the member;
            // an `id` attribute in the heading or in an element that follows provides
            // the information.
            case "h1": case "h2": case "h3": case "h4":
                contentBuffer = new StringBuilder();
                if (inDetails && !inDescription && name.equals(detailHeading)) {
                    debugPrintln(() -> "!! start description because inDetails but !inDescription");
                    inDescription = true;
                    descriptionId = null;
                }
                break;

            // Some versions of javadoc use two sections for the description, instead of one.
            // This is handled by reading sections until the first `<ul>` element that is not
            // part of the description. For these versions of javadoc, this `<ul>` introduces
            // the summary sections.
            case "ul":
                if (inDescription) {
                    blockDepth++;
                } else {
                    allowMoreModuleSections = false;
                }
                break;
        }

        // id attributes are used to help identify the beginning of descriptions
        // and (for members) the basic signature of the member itself.
        String id = attrs.get("id");
        switch (kind) {
            // For a module, the main description is a section containing
            // `id="module-description"` or `id="module.description"`
            case MODULE:
                if (inDescription && descriptionId == null && id != null) {
                    if (isModuleDescription(attrs)) {
                        debugPrintln(() -> "!! commit description for MODULE");
                        descriptionId = id;
                        allowMoreModuleSections = true;
                    } else {
                        debugPrintln(() -> "XX cancel description for MODULE");
                        inDescription = false;
                    }
                }
                break;

            // For a package, the main description is a section containing
            // `id="package-description"` or `id="package.description"`
            case PACKAGE:
                if (inDescription && descriptionId == null && id != null) {
                    if (isPackageDescription(attrs)) {
                        debugPrintln(() -> "!! commit description for PACKAGE");
                        descriptionId = id;
                    } else {
                        debugPrintln(() -> "XX cancel description for PACKAGE");
                        inDescription = false;
                    }
                }
                break;

            // For a type, identifying the main description does not depend on
            // any `id` attribute (it depends on the element and class).
            // But, an `id` in the details part of the file may indicate the
            // beginning of the description of a member, or may provide the
            // `declarationId` if the description has already been started ...
            // for example, by a heading.
            case TYPE:
                if (inDetails && descriptionId == null && (id != null) && !id.matches("[a-z]+[-.]detail[s]?")) {
                    if (!inDescription) {
                        debugPrintln(() -> "!! start description for TYPE " + id);
                        inDescription = true;
                        blockDepth = 0;
                    }
                    debugPrintln(() -> "!! set id for TYPE member " + id);
                    descriptionId = id;
                }
                break;
        }

        debugPrintln(() -> "   inDesc:" + inDescription + " depth:" + blockDepth + " descId:" + descriptionId);
    }

    /*
     * Match the following strings:
     *   Constructor Detail
     *   Element Detail
     *   Enum Constant Detail
     *   Field Detail
     *   Method Detail
     *
     * For now, it's a weak match.
     * If we get false positives, we can strengthen the match.
     * Ideally, we should not need to rely on javadoc's marker comments.
     *
     * The headings would be more grammatically correct if they were
     * plural, and ended in "s". The pattern proactively anticipates this
     * possibility.
     */
    private final Pattern detail = Pattern.compile("(?i)[a-z ]+ detail[s]?");

    @Override
    protected void endElement(String name) {
        // skip everything not in the `<main>` element
        if (!inMain) {
            return;
        }

        debugPrintln(() -> "</" + name + ">" + blockDepth);
        switch (name) {
            case "div":
                if (inSubTitle) {
                    String subTitle = contentBuffer.toString().replace("&nbsp;", " ");
                    debugPrintln(() -> "subTitle: " + subTitle);
                    setDeclarationName(subTitle);
                    inSubTitle = false;
                }
                break;

            case "h1": case "h2": case "h3": case "h4":
                String content = contentBuffer.toString();
                if (inHeader) {
                    String heading = content.replace("&nbsp;", " ");
                    debugPrintln(() -> "heading: " + heading);
                    setDeclarationName(heading);
                    inHeader = false;
                } else if (detail.matcher(content).matches()) {
                    debugPrintln(() -> "START inDetails");
                    inDetails = true;
                    detailHeading = "h" + (char)(name.charAt(1) + 1);
                    debugPrintln(() -> "detailHeading: " + detailHeading);
                }
                break;

            // nothing more to do
            case "main":
                inDetails = false;
                inMain = false;
                break;
        }

        // Once a description has been started, in general the description is ended
        // when the block nesting level drops to zero.
        if (inDescription) {
            switch (name) {
                case "section":
                case "div":
                case "ul":
                    if (--blockDepth == 0) {
                        String d = getBufferString(startDescriptionIndex, getBufferIndex());
                        switch (kind) {
                            case MODULE:
                                // Some versions of javadoc use multiple section elements for the
                                // description of a module, so we concatenate them here.
                                debugPrintln(() -> ("*** " + kind + ":\n" + d).replace("\n", "\n*** "));
                                description = (description == null) ? d : description + d;
                                break;

                            case PACKAGE:
                                debugPrintln(() -> ("*** " + kind + ":\n" + d).replace("\n", "\n*** "));
                                description = d;
                                break;

                            case TYPE:
                                // Determine whether this is the end of the main description, or the end of the description
                                // of a member.
                                if (descriptionId == null) {
                                    debugPrintln(() -> ("*** " + kind + ":\n" + d).replace("\n", "\n*** "));
                                    description = d;
                                } else {
                                    debugPrintln(() -> ("*** " + kind + ": " + descriptionId + "\n" + d).replace("\n", "\n*** "));
                                    memberDescriptions.put(descriptionId, d);
                                }
                                break;
                        }
                        inDescription = false;
                        descriptionId = null;
                    }
            }
        }
    }

    /**
     * Module descriptions are recognised as one of the following:
     *   {@code }<TAG id="module-description">}
     *   {@code }<TAG id="module.description">}
     *
     * @param attrs the attributes
     * @return whether the attributes indicate a class description
     */
    private boolean isModuleDescription(Map<String, String> attrs) {
        String id = attrs.get("id");
        if (id == null) {
            return false;
        }

        return switch (id) {
            case "module-description",      // new style
                 "module.description" ->    // old style
                true;

            default ->
                false;
        };
    }

    /**
     * Package descriptions are recognised as one of the following:
     *   {@code }<TAG id="package-description">}
     *   {@code }<TAG id="package.description">}
     *
     * @param attrs the attributes
     * @return whether the attributes indicate a class description
     */
    private boolean isPackageDescription(Map<String, String> attrs) {
        String id = attrs.get("id");
        if (id == null) {
            return false;
        }

        return switch (id) {
            case "package-description",     // new style
                 "package.description" ->   // old style
                true;

            default ->
                false;
        };
    }

    /**
     * Class descriptions are recognised as one of the following:
     *   {@code }<TAG class="class-description" id="class-description>}
     *   {@code }<TAG class="description">}
     *
     * @param attrs the attributes
     * @return whether the attributes indicate a class description
     */
    private boolean isClassDescription(Map<String, String> attrs) {
        String id = attrs.get("id");
        if (id != null) {
            return id.equals("class-description"); // new style
        } else {
            return Objects.equals(attrs.get("class"), "description"); // old style
        }
    }

    private void setDeclarationName(String keyValue) {
        Pattern p = Pattern.compile("(?<key>[A-Za-z]+):?\\s+(?<value>[A-Za-z0-9_$.]+)");
        Matcher m = p.matcher(keyValue);
        if (m.matches()) {
            if (declarationNames == null) {
                declarationNames = new LinkedHashMap<>();
            }
            declarationNames.putIfAbsent(
                    m.group("key").toLowerCase(Locale.ROOT),
                    m.group("value"));
        }
    }

    private Kind getKind(Path file) {
        return switch (file.getFileName().toString()) {
            case "module-summary.html" -> Kind.MODULE;
            case "package-summary.html" -> Kind.PACKAGE;
            default -> Kind.TYPE;
        };
    }
}
